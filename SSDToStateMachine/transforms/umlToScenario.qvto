modeltype UML uses  "http://www.eclipse.org/uml2/5.0.0/UML";
modeltype ScenarioModel uses "mm:sequencediagram";

transformation umlToScenario(in ssd: UML, out scenarios: ScenarioModel) ;

property actorStateDict : Dict(String, String);
main() {
	//ssd.objectsOfType(Model)->map modelToScenario();
	ssd.objectsOfType(InteractionFragment)->map interactionFragmentToScenario();
}


mapping InteractionFragment::interactionFragmentToScenario() : Scenario {
	self->forEach(interactionFragment) {
		
		
		if (interactionFragment.oclIsTypeOf(StateInvariant)) {
			var stateInvariant := interactionFragment.oclAsType(StateInvariant);
			var lifelines := stateInvariant.covered;
			lifelines->forEach(lifeline) {
				actorStateDict->put(lifeline.name, stateInvariant.name);
				communication->forEach(comm | comm.oclIsKindOf(SystemCommunication)) {
					var systemCommunication := comm.oclAsType(SystemCommunication);
					//check if there is no postState
					if (systemCommunication.secondState = null and systemCommunication.systemmessage.systemobject.name = lifeline.name) {
						systemCommunication.secondState := lifeline.createStateFromDict();
					}
					
				}
			};
			
			
		}
		else if (interactionFragment.oclIsTypeOf(MessageOccurrenceSpecification))  {
			var mos = interactionFragment.oclAsType(MessageOccurrenceSpecification);
			if (mos.isSend()){
				if (mos.message.messageSort = MessageSort::synchCall) {
					if (mos.message.receiveEvent.isUser()) {
						communication +=  mos.message.map messageToUserCommunication();
					}	
					else {
						communication +=  mos.message.map messageToSystemCommunication();
					}
				}
			}
		
			
		}
	};
	
	 
	/*sendingMessages->forEach(mos) {
		if (self.message.receiveEvent.isUser()) {
			communication +=  self.message.map messageToUserCommunication();
		} else {
			communication +=  mos.message.map messageToSystemCommunication();
		};
	};*/
	
	/*replyMessages->forEach(mos) {
	
		log("Found Message with MessageSort reply: " + mos.message.name);
		// if message held by the MessageOccurrenceSpecification is of sort reply then fetch the last communication that can be the request to this reply and map the reply message to it
		var lastCommFromRecToSend : SystemCommunication := communication->select(c | c.oclIsTypeOf(SystemCommunication) and c.oclAsType(SystemCommunication).sysCommCanBeRequestForReply(mos.message))->last().oclAsType(SystemCommunication);
		lastCommFromRecToSend.returnValue.value := mos.message.name;
		log("Map it as Return to SystemCommunication: " + lastCommFromRecToSend.operation.name);
			
	};*/
	
	
	
	

	self->selectByType(Lifeline)->forEach(l) {
		//TODO iterate over all lifelines to assign correct post state
	}
	
}



mapping Model::modelToScenario() : Scenario {
	var lifelines := self.packagedElement->selectByType(Lifeline);
	var userLifelines := lifelines->select(l | l.name.toLower().endsWith("user"));
	
	
	
	/*userLifelines->forEach(l) {
		var interaction := l.container().oclAsType(Interaction);
		interaction->message->forEach(m) {
			if (m.sendEvent.message.sendEvent = MessageSort::synchCall) {
				//we have found a message, the user is sending
			}
			else if (m.messageSort = MessageSort::asynchCall) {
				// we have found a message, the user is receiving from a system object
			}
			m->
			
			
		}
		
	};
		
	
		
	if (m.sendEvent.message.messageSort = (MessageSort::asynchSignal)) {
			
		}*/
	
	
	/*result.communication += interactions->map interactionToUserCommunication(); //deal with user communications
	result.communication += interactions->map interactionToSystemCommunication() //deal with system communications
	*/
	//result.communication += self.packagedElement->select(i | i.oclIsKindOf(Interaction))->map interactionToUserCommunication()
}

mapping Lifeline::getSyncMessages() : Message {
	
}


mapping Message::messageToUserCommunication() : UserCommunication {
	
}

mapping Message::messageToSystemCommunication() : SystemCommunication {
	
}

mapping Interaction::interactionToUserCommunication() : UserCommunication {

	
	self.lifeline->select(l | l.name.toLowerCase().endsWith("user"))->map userLifelineToUserCommunication();
	//var userLifelines = self.lifeline->select(l | l.name.toLowerCase().endsWith("user"));
	//var systemLifelines = self.lifeline - userLifelines;
	
	/*self.lifeline->forEach(l | l.name.toLowerCase().endsWith("user")) {
		var interaction := l.container().oclAsType(Interaction);
		interaction.message->forEach(m | m.sendEvent.oclAsType(MessageOccurrenceSpecification).message.messageSort = MessageSort::synchCall) {
			//we have found a synchronous message from our 
		};
	};*/
	
	



	var sendEvent := self.message->any(true)->sendEvent.oclAsType(MessageOccurrenceSpecification);
	var receiveEvent := self.message->any(true)->receiveEvent.oclAsType(MessageOccurrenceSpecification);

	
}

mapping Lifeline::userLifelineToUserCommunication() : UserCommunication {
	var interaction : Interaction = self.container().oclAsType(Interaction);
}

mapping Interaction::interactionToSystemCommunication() : SystemCommunication when {
	not(self.name.toLowerCase().endsWith("user")); //we're only dealing with system interactions here
}{
	
		
}

query MessageEnd::isUser() : Boolean {
	var lifeline := self.oclAsType(MessageOccurrenceSpecification).getCovered();
	return lifeline.name.isUser();
}
query String::isUser() : Boolean {
	return self.toLower() = "user";
}
query Lifeline::createStateFromDict() : ssdRoot::State {
	return object ssdRoot::State {
		name := actorStateDict->get(self.name);
	}
}


