modeltype UML uses "http://www.eclipse.org/uml2/5.0.0/UML";
modeltype IOAutomatonModel uses "mm:ioautomaton";

transformation automatonToStatemachine(in automata: IOAutomatonModel, out statemachines: UML);

main() {
	log("\n\nTransformation IOAutomatonModel -> Statemachine");
	log("#Automaton container: " + automata.objectsOfType(AutomatonContainer)->size().toString());
	var automatacontainer := automata.objectsOfType(AutomatonContainer);
	automatacontainer->map automatonContainerToStatemachineContainer();	
}

mapping AutomatonContainer::automatonContainerToStatemachineContainer() : UML::Model {
	log("#Automata: " + self.automaton->size().toString());
	
	var statemachine := createUMLModel();
	
	statemachine.packagedElement += self.automaton->map automatonToStatemachine();
}

query createUMLModel() : UML::Model {
	return object UML::Model {
		name := "Generated state machine from sequence diagrams";
	};
}


mapping Automaton::automatonToStatemachine() : UML::StateMachine {
	log("\nMapping automaton of sender " + self.sender);
	
	name := "UML State Machine for " + self.sender;
		
	var mainRegion = createRegion(self);
	region += mainRegion; 

}

query createRegion(automaton: Automaton) : UML::Region {
	
	var region := object UML::Region {
		name := "Main region from state machine for " + automaton.sender;
	};
	
	region.subvertex += automaton.state.map createUMLStableState();
	
	var activityStates := automaton.map createUMLActivityState();
	region.subvertex += activityStates;	
	region.transition += automaton.createTransitions(region.subvertex);
	
	activityStates->forEach(state) {
		state.submachine := state.createSubmachine(automaton.transition);
	};
	
	return region;
}

query Automaton::createTransitions(states: Set(UML::Vertex)) : Set(UML::Transition) {
	
	var resultSet : Set(UML::Transition);
	
	//save the already added transitions, adding them once is sufficient
	var addedTransitions: Set(String);
		
	self.transition->forEach(transition) {
		
		if (not addedTransitions->exists(t | t = transition.prestate.name + " -> " + transition.operation.name)) {
			
			var  ingoingumltransition := object UML::Transition {
				name := transition.prestate.name + " -> " + transition.operation.name;
				addedTransitions += name;
				source := states->findVertexWithName(transition.prestate.name);
				target := states->findVertexWithName(": " + transition.operation.name);
				trigger := object UML::Trigger {
					name := transition.operation.name;
				};
				log("Transition added: " + name + " with trigger " + transition.operation.name);
			};
			
			resultSet += ingoingumltransition;
		};
		
		var  outgoingumltransition := object UML::Transition {
			name := transition.operation.name + " -> " + transition.poststate.name;
			source := states->findVertexWithName(": " + transition.operation.name);
			target := states->findVertexWithName(transition.poststate.name);
			effect := object OpaqueBehavior {
				name := "return " + transition._return.value;
				body := "return " + transition._return.value;
				language := "en";
			};
			
			log("Transition added: " + name + " with return value " + transition._return.value);
		};
			
		resultSet += outgoingumltransition;
	};
	
	
	return resultSet;
	
}

query UML::State::createSubmachine(transitions : Set(ioautomaton::Transition)) : UML::StateMachine {
	
	var statemachine := object  UML::StateMachine {
		name := self.name;
	};
	
	var region = object UML::Region { 
		name := "Main region of statemachine from activity state " + self.name; 
	};
	statemachine.region += region;
	
	var entry := object UML::Pseudostate {
		kind := UML::PseudostateKind::entryPoint;
	};
	
	region.subvertex += entry;
	
	var transitionsWithCorrectOperationName := transitions->select(t | t.operation.name = self.name.substituteFirst(": ", ""));
	log("For operation " + self.name.substituteFirst(": ", "") + ", " + transitionsWithCorrectOperationName->size().toString() + " relevant tranistions were found");
	
	var allReceiverNames : Set(String);
	var receiverOperationDict : Dict(String, Set(String));
	transitionsWithCorrectOperationName->forEach(t) {
		
		if (t.outmessage->size() = 0) {
			continue;
		};
		
		var receiver := t.outmessage->first()._object.name;			
		if (not allReceiverNames->exists(s | s = receiver)) {
			allReceiverNames += receiver;
			receiverOperationDict->put(receiver, object Set(String){});
			log("Receiver name " + receiver + " added");
		} else {
			log("Receiver already added");
		};
		if (not receiverOperationDict->get(receiver)->exists(s | s = t.outmessage->first().operation.name)) {
			var recSet := receiverOperationDict->get(receiver);
			recSet += t.outmessage->first().operation.name;
			receiverOperationDict->put(receiver, recSet);
			
			var opname : String;			
			if (t.outmessage->first().operation = null) {
				opname := "null";
			} else {
				opname := t.outmessage->first().operation.name;
			};
			log("For receiver name " + receiver + " the operation " + opname + " was found");
		} else {
			log("Receiver operation combination already added");
		}		
	};
	
	if (allReceiverNames->size() = 0) {
		return null;
	};
	
	allReceiverNames->forEach(receiver) {		
		receiverOperationDict->get(receiver)->forEach(operation) {
			
			var relevantTransitions := transitionsWithCorrectOperationName->select(t | t.outmessage->first()._object.name = receiver and t.outmessage->first().operation.name = operation);
			
			var opname : String;			
			if (operation = null) {
				opname := "null";
			} else {
				opname := operation;
			};
			log("#relevant transitions for receiver " + receiver + " and operation " + opname + " : " + relevantTransitions->size().toString());
			
			var firstState := object UML::State {
				name := receiver + "." + operation;
				doActivity := object OpaqueBehavior {
					name := "check := " + receiver + "." + operation;
					body := "check := " + receiver + "." + operation;
					language := "en";
				}
			};
			
			region.subvertex += firstState;
			
			region.transition += object UML::Transition {
				name := "entry->" + receiver + "." + operation;
				source := entry;
				target := firstState;
			};
			
			var possibleReturnValues : Set(String);
			relevantTransitions->forEach(t) {
				if (not possibleReturnValues->exists(s | s = t._return.value)) {
					possibleReturnValues += t._return.value;
				}
			};
			
			possibleReturnValues->forEach(returnVal) {
				var state := object UML::State {
					name := "check = " + returnVal;
					doActivity := object OpaqueBehavior {
					name := "check := " + receiver + "." + operation;
					body := "check := " + receiver + "." + operation;
					language := "en";
				}
				}
			}
		}
	};
	
	return statemachine;
	
}

query Set(UML::Vertex)::findVertexWithName(name : String) : UML::Vertex {	
		
	self->forEach(vertex) {
		if (vertex.name = name) {
			return vertex;
		}
	};
	
	log("!!!!! vertex with name " + name + "not found");
	return null;
}

mapping ioautomaton::State::createUMLStableState() : State {
	
	init {	
		result := object UML::State {
			name := self.name;
			log("State " + name + " created");
		};
	}
}

mapping Automaton::createUMLActivityState() : Set(UML::State) {
	init {	
		var states: Set(String);
		
		self.transition->forEach(transition) {
			
			if (not states->exists(s | s = transition.operation.name))	{	
				result += object UML::State {
					name := ": " + transition.operation.name;
					states += transition.operation.name;
					log("State " + name + " created");
				};
			}
		}
	}
	
	
}



//helper String::generateSubmachines(in iOAutomaton : ioautomaton::Automaton, inout mainReg : statemachine::Region ) : statemachine::Statemachine{
//	var subMach := self.map stringToStateMachine();
//	var reg := self.map stringToRegion();
//	subMach.region := reg;
//	
//	/// Etry State
//	var initState = self.map constructEntryState();	
//	reg.subvertex += initState;
//	
//	//State for mainRegion, where this function is called define now
//	var submachineState := self.map constructState();
//	submachineState.entryPoint := initState;
//	
//	///Transitions from IOAutomaton used in this submachine
//	var relatedTransitions := iOAutomaton.transition->select(inmessage != null)->select(inmessage.operation.name=self)->asSequence();
//	var first := constructNextStepOfAlgorithm(relatedTransitions,1,reg, mainReg,submachineState); //first Actual state in this Submachine
//	
//	//transition to this state
//	var trans := map constructTransition(initState,first);
//	reg.transition += trans;
//	
//	//State for mainRegion, where this function is called
//	submachineState.submachine := subMach;
//	mainReg.subvertex += submachineState;
//	
//	//connect inside main region
//	var sourceStateName := relatedTransitions.source->first().oclAsType(State).name; //all calling states are the same
//	var sourceState := mainReg.subvertex->selectByKind(StateMachine::State).oclAsType(StateMachine::State)->select(name=sourceStateName); //can't be pseudo' 
//	var inTrans = map constructTransition(sourceState->first(),submachineState);//first save, as only one possible
//	inTrans.trigger := self.map constructTrigger();
//	mainReg.transition += inTrans;
//	
//	return subMach;
//}
//

//helper constructNextStepOfAlgorithm(in corrTransitions : Sequence(IOAutomaton::Transition),
//		in count : Integer, inout reg : StateMachine::Region, inout mainReg : StateMachine::Region, inout submachineState: StateMachine::State) : StateMachine::Vertex{
//	
//	var oMessages := corrTransitions->first().outmessage->asSequence(); //All transitions related to this function
//	var doActivityCode := ""; //build statename
//	var i := count; //location in message
//	
//	//collect all messages without return type
//	while(oMessages->at(i).returnvalue.oclIsKindOf(VoidValue) and i <= oMessages->size()){
//		doActivityCode := doActivityCode + oMessages->at(i).getOutMessageSignature();
//		i := i + 1;
//	};
//	
//	//with returntype add call to statename
//	if( oMessages->at(i).returnvalue.oclIsKindOf(Value) and i <= oMessages->size() ){
//		doActivityCode := doActivityCode + oMessages->at(i).getOutMessageSignature();
//	};
//	
//	//construct states
//	var state := doActivityCode.map constructActionState(submachineState.name);
//	
//	if(i != count){	
//		reg.subvertex += state;		
//	};
//	var b = false;
//	//if return value create branch and connect to state, if this happens we don't have final states yet
//	if( oMessages->at(i).returnvalue.oclIsKindOf(Value) and i <= oMessages->size() ){
//		reg.subvertex += state;
//		var results = corrTransitions.getResultsAt(i)->asSet(); //all different results
//		results->forEach(res){
//			//split by result and call this step again
//			var resultingTransactions :=  corrTransitions->select(outmessage->at(i).returnvalue.oclAsType(Value).name = res);
//			if(i+1<=resultingTransactions->first().outmessage->asSequence()->size()){
//				var next := constructNextStepOfAlgorithm(resultingTransactions,i+1,reg, mainReg,submachineState);
//				//conect this state to the result state
//				var condition := "check = " + res;
//				var trans := condition.map constructGuardedTransition(state,next);
//				reg.transition += trans;
//			};
//			if(not (i+1<=resultingTransactions->first().outmessage->asSequence()->size())){
//				//Final state is next
//				var exitState := resultingTransactions.target.oclAsType(State).name.map constructExitState(submachineState.name,(resultingTransactions->first().returnvalue.map toEffect()).desc);
//				reg.subvertex += exitState;
//				var condition := "check = " + res;
//				//reg.transition += map constructTransition(state,exitState->first()); //save there is only one
//				log("verify",submachineState.name);
//				//Connect Inside Main
//				var targetStateName := resultingTransactions.target->first().oclAsType(State).name; //all calling states are the same
//				var targetState := mainReg.subvertex->selectByKind(StateMachine::State).oclAsType(StateMachine::State)->select(name=targetStateName); //can't be pseudo' 
//				var effect := resultingTransactions->first().returnvalue.map toEffect();
//				var outTrans = map constructTransition(submachineState,targetState->first(),effect);//first save, as only one possible
//
//				//targetState->first().exitPoint += exitState;
//				submachineState.exitPoint += exitState;
//				
//				mainReg.transition += outTrans;
//				//conect this state to the result state
//				
//				var trans := condition.map constructGuardedTransition(state,exitState->first());
//				reg.transition += trans;
//				b:=true;
//			};
//		};
//	};
//
//	//should never occur, as this is loop condition, but to do a complete case for Kind
//	if(oMessages->at(i).returnvalue.oclIsKindOf(VoidValue) and i <= oMessages->size()){
//		log("ERROR","should never be called");
//	};
//	if(not((i != count) or (oMessages->at(i).returnvalue.oclIsKindOf(Value) and i <= oMessages->size()))){
//		reg.subvertex +=  state;
//	};
//	if(b){
//		return state;
//	};
//	
//	//add state to vertex, in this case we have one and only one final state
//	if(i != count or not (oMessages->at(i).returnvalue.oclIsKindOf(Value) and i <= oMessages->size()) ){
//		var exitState := corrTransitions.target.oclAsType(State).name.map constructExitState(submachineState.name,(corrTransitions->first().returnvalue.map toEffect()).desc);
//		reg.subvertex += exitState;
//		reg.transition += map constructTransition(state,exitState->first()); //save there is only one
//		
//		//Connect Inside Main
//		var targetStateName := corrTransitions.target->first().oclAsType(State).name; //all calling states are the same
//		var targetState := mainReg.subvertex->selectByKind(StateMachine::State).oclAsType(StateMachine::State)->select(name=targetStateName); //can't be pseudo' 
//		var effect := corrTransitions->first().returnvalue.map toEffect();
//		var outTrans = map constructTransition(submachineState,targetState->first(),effect);//first save, as only one possible
//		
//		//targetState->first().exitPoint += exitState;
//		submachineState.exitPoint += exitState;
//		
//		mainReg.transition += outTrans;
//	};
//	
//	
//	return state;
//}
//
//
//mapping  String::constructGuardedTransition(in sou : StateMachine::Vertex, in tar : StateMachine::Vertex) : StateMachine::Transition{
//	guard := self.map constructConstraint();
//	source := sou;
//	target := tar;
//}
//
//mapping  constructTransition(in sou : StateMachine::Vertex, in tar : StateMachine::Vertex) : StateMachine::Transition{
//	source := sou;
//	target := tar;
//}
//
//mapping  constructTransition(in sou : StateMachine::State, in tar : StateMachine::State, in eff : StateMachine::Behavior) : StateMachine::Transition{
//	source := sou;
//	target := tar;
//	effect := eff;
//}
//
//mapping  constructTransition(in sou : StateMachine::Vertex, in tar : StateMachine::Vertex, in eff : String) : StateMachine::Transition{
//	source := sou;
//	target := tar;
//	name := eff;
//}
//
//mapping  String::constructConstraint() : StateMachine::Constraint{
//	constraint := self;
//}
//
//
//helper IOAutomaton::Transition::getResultsAt(in i:Integer) : String {
//	return self.outmessage->at(i).returnvalue.oclAsType(Value).name;
//}
//
//mapping String::constructTrigger() : StateMachine::Trigger{
//	trigger := self;
//}
//
//helper IOAutomaton::OutMessage::getOutMessageSignature() : String {
////TODO check only if return value
//	var ret := "";
//	if(self.returnvalue.oclIsKindOf(Value)){
//		ret := " check := ";
//	};
//	return ret+getRecieverName(self.actorobject)+"."+self.operation.name+" ";
//}
//mapping String::constructActionState(in subMachName : String) :  StateMachine::State{
//	name := subMachName+":"+self;
//	doActivity := self.map constructCodeBlock();
//}
//
//
//
//mapping String::constructCodeBlock() : StateMachine::CodeBlock{
//	desc := self;
//}
//
//helper getRecieverName(in act : IOAutomaton::ActorObject) : String {
//	if(act.oclIsKindOf(User))
//		return "User";
//	return act.oclAsType(SystemObject).name;
//}
//
//
//
//mapping String::constructInitState() : StateMachine::PseudoState {
//	name := self;
//	pseudoStateKind := PseudoStateKind::initial;
//}
//
//mapping String::constructEntryState() : StateMachine::PseudoState {
//	name := self;
//	pseudoStateKind := PseudoStateKind::entryPoint;
//}
//
//mapping String::constructExitState(in submachineName: String, in retVal : String) : StateMachine::PseudoState {
//	name := submachineName+":"+self;
//	pseudoStateKind := PseudoStateKind::exitPoint;
//	returnValue := retVal;
//}
//
//
//	          
//
//	          	          
//mapping IOAutomaton::InitialState::toInitialState() : StateMachine::PseudoState {
//	name := "entry";
//	pseudoStateKind := PseudoStateKind::initial;
//}
//
//
//mapping String::constructState() : statemachine::State {
//	name := self;
//}
//
//mapping IOAutomaton::InMessage::toAcivityState() : StateMachine::State{
//	name := self.operation.name;
//}
//
//mapping IOAutomaton::ReturnValue::toEffect() : StateMachine::CodeBlock 
//	disjuncts 
//		 IOAutomaton::Value::toEffect,
//		IOAutomaton::VoidValue::toEffect;
//	
//
//mapping IOAutomaton::Value::toEffect() : StateMachine::CodeBlock {
//	desc := "return " + self.name;
//}
//mapping IOAutomaton::VoidValue::toEffect() : StateMachine::CodeBlock{
//	desc := "return void";
//} 
//
//
//
//
