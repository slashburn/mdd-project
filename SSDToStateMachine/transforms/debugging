modeltype IOAutomatonModel uses "mm:ioautomaton";

transformation mergeAutomatons(in automata: IOAutomatonModel, out mergedAutomaton: IOAutomatonModel);

main() {
	log("\n\nTransformation Automata -> Automaton");
	automata.objectsOfType(AutomatonContainer)->map mergeAutomatons();	
}

/*mapping AutomatonContainer::mergeAutomatons() : AutomatonContainer {
		
	self.automaton.sender->asSet()->forEach(sender) {
		log("Mapping automaton for " + sender);
		
		var senderAutomata := self.automaton->select(automaton | automaton.sender = sender);
		var resultAutomaton := senderAutomata->mergeAutomata();
		resultAutomaton.sender := sender;
		result.automaton += resultAutomaton;
	}
	
}*/

mapping AutomatonContainer::mergeAutomatons() : AutomatonContainer {
	
	init {
		log("Start merge()");
	
		var mainActorNames := self.automaton.sender->asSet();
		var automataResult := object AutomatonContainer{};
		mainActorNames->forEach(mainActorName | true) {
			log("Actor " + mainActorName);
			var automataForActor := self.automaton->select(automaton | automaton.sender = mainActorName);
			var mergedAutomaton := automataForActor->mergeAutomata();

			mergedAutomaton.sender := mainActorName;
			automataResult.automaton += mergedAutomaton;
		};
		result := automataResult;
	}
	
	end {
		log("Finished automata merge()");
	}
}

query Set(State)::isStateContained(state : State) : Boolean {
	var stateName = state.name;
	return self->exists(setState | setState.name = stateName);
}

helper Set(Automaton)::mergeAutomata() : Automaton {
	var mergedAutomaton := object Automaton{};
	
	var uniqueStates : Set(State) := Set{};
	self->forEach(automaton | true) {
		automaton.state->forEach(state | not uniqueStates->isStateContained(state)) {
			var uniqueState := object State {
				name := state.name;
			};
			log("Add unique state " + uniqueState.name);
			uniqueStates += uniqueState;
		};
		mergedAutomaton.initialstate := automaton.initialstate;
	};
	
	var uniqueTransitions : Set(Transition) := Set{};
	self->forEach(automaton | true) {
		automaton.transition->forEach(transition | not uniqueTransitions->containsTransition(transition)) {
			var uniqueTransition := object Transition{};
			uniqueTransition.operation := createOperation(transition.operation.name);
			uniqueTransition.outmessage := createOutMessages(transition.outmessage);
			uniqueTransition._return := createReturn(transition._return.value);
			uniqueTransition.prestate := uniqueStates->findState(transition.prestate.name);
			uniqueTransition.poststate := uniqueStates->findState(transition.poststate.name);
			log("Add unique transition " + uniqueTransition.prestate.name + " -> " + uniqueTransition.poststate.name + "(" + uniqueTransition.operation.name + ")");
			uniqueTransitions += uniqueTransition; // uniqueTransition.automaton assigned automatically
		};
	};
	
	uniqueStates->forEach(uniqueState | true) {
		var reassignedIncomingTransitions : Set(Transition) := Set{};
		uniqueState.incomingtransition->forEach(transition | true) {
			reassignedIncomingTransitions += uniqueTransitions->findTransition(transition.prestate, transition.poststate);
		};
		uniqueState.incomingtransition := reassignedIncomingTransitions;
		
		var reassignedOutgoingTransitions : Set(Transition) := Set{};
		uniqueState.outgoingtransition->forEach(transition | true) {
			reassignedOutgoingTransitions += uniqueTransitions->findTransition(transition.prestate, transition.poststate);
		};
		uniqueState.outgoingtransition := reassignedOutgoingTransitions;
	};
	
	mergedAutomaton.state := uniqueStates;
	mergedAutomaton.transition := uniqueTransitions;
	var startState := self->asSequence()->first().oclAsType(Automaton).initialstate;
	mergedAutomaton.initialstate := mergedAutomaton.state->findState(startState.name);
	return mergedAutomaton;
}

/*helper Set(Automaton)::mergeAutomata(sender : String) : Automaton {
	var resultAutomaton := object Automaton {};
	
	//eliminate duplicates
	var duplicateFreeStates := eliminateDuplicateStates(self);
	var duplicateFreeTransitions := eliminateDuplicateTransitions(self, duplicateFreeStates);
	
	duplicateFreeStates->forEach(state) {
//		state.incomingtransition->forEach(transition) {
//			if (transition.prestate = null) {
//				log("problem!!!");
//			};
//		};
		adjustTransitions(state, duplicateFreeTransitions);
	};
	
	resultAutomaton.state := duplicateFreeStates;
	resultAutomaton.initialstate := resultAutomaton.state-> findState(self->asSequence()->first().initialstate.name);	
	resultAutomaton.transition := duplicateFreeTransitions;
	return resultAutomaton;
}*/

/*
helper adjustTransitions(inout state: State, duplicateFreeTransitions: Set(Transition)) {
	
	log("Adjust transitions for state: " + state.name);
	
	var adjustedIncomingTransitions : Set(Transition);
	state.incomingtransition->forEach(transition) {
		adjustedIncomingTransitions += duplicateFreeTransitions->findTransition(transition.prestate, transition.poststate);
	};
	state.incomingtransition := adjustedIncomingTransitions;
	
	
	var adjustedOutgoingTransitions : Set(Transition);
	state.outgoingtransition->forEach(transition) {
		adjustedOutgoingTransitions += duplicateFreeTransitions->findTransition(transition.prestate, transition.poststate);
	};
	state.outgoingtransition := adjustedOutgoingTransitions;	
}
*/
query Set(Transition)::findTransition(prestate: State, poststate: State) : Transition {
	self->forEach(transition | transition.prestate.name = prestate.name and transition.poststate.name = poststate.name) {
		return transition;
	};
	var postname := "null";
	if (poststate != null) {
		postname := poststate.name;
	};
	var prename := "null";
	if (prestate != null) {
		prename := prestate.name;
	};
	log("!!!!!fatal error: Transition in findTransition(mergeAutomaton.qvto) not found: " + prename + "->" + postname);
	return null;
}
/*
helper eliminateDuplicateTransitions(allAutomata: Set(Automaton), duplicateFreeStates:Set(State)) : Set(Transition) {
	var transitions : Set(Transition);
	
	allAutomata->forEach(automaton) {
		automaton.transition->forEach(transition | not transitions->containsTransition(transition)) {
			transitions += createTransition(transition, duplicateFreeStates);
		}
	};
	return transitions;
}

query createTransition(transition: Transition, states: Set(State)) : Transition {
	return object Transition {
		operation := createOperation(transition.operation.name);
		outmessage := createOutMessages(transition.outmessage);
		_return := createReturn(transition._return.value);
		prestate := states->findState(transition.prestate.name);
		poststate := states->findState(transition.poststate.name);
		log("created new transition: "+ prestate.name + " -> "+ poststate.name + "(" + operation.name + ")");
	}
	
	
}*/
query Set(State)::findState(stateName: String) : State {
	self->forEach(state | state.name = stateName) {
		return state;
	};
	log("!!!!!fatal error: state in findState(mergeAutomaton.qvto) not found: " + stateName);
	return null;
}
/*
query Set(Transition)::containsTransition(transition: Transition) : Boolean {
	self->forEach(t) {
		if(	t.operation.name != transition.operation.name or 
			t.prestate.name != transition.prestate.name or
		 	t.poststate.name != transition.poststate.name or
		 	t.outmessage->size() != transition.outmessage->size()) {
		 	
		 	continue;
		};
		
		var transitionsSetsNotEqual := false;
		t.outmessage->forEach(outMsg | not transition.outmessage->containsOutMessage(outMsg)){
			transitionsSetsNotEqual := true;
			break;
		};
		if(transitionsSetsNotEqual) {
			continue;
		};
		return true;	
	};
	return false;
}*/

query Set(Transition)::containsTransition(transition : Transition) : Boolean {
	var outMessages := transition.outmessage;
	self->forEach(setTransition 
					| setTransition.operation.name = transition.operation.name
					and setTransition.prestate.name = transition.prestate.name
					and setTransition.poststate.name = transition.poststate.name) {
		// operation, pre and post equal
		// now check the outMessages
		if(not (outMessages->size() = setTransition.outmessage->size())) {
			return false;
		};
		var outProduct := outMessages->product(setTransition.outmessage);
		var equalCount := 0;
		outProduct->forEach(outProdTuple | true) {
			var first := outProdTuple.first;
			var second := outProdTuple.second;
			if (first.operation.name = second.operation.name
					and first._object.name = second._object.name
					and first._return.value = second._return.value) {
				equalCount := equalCount + 1;
			}
		};
		if(equalCount = outMessages->size()) {
			return true;
		}
	};
	return false;
}


/*
query Set(OutMessage)::containsOutMessage(outMessage: OutMessage) : Boolean {
	self->forEach(message) {
		if(	message._return.value = outMessage._return.value and
			message.operation.name = outMessage.operation.name and 
			message._object.name = outMessage._object.name) {
			
			return true;
			
		}
	};
	return false;
}

helper eliminateDuplicateStates(allAutomata: Set(Automaton)) : Set(State) {
	var stateDict : Dict(String, State);
	
	allAutomata->forEach(automaton) {
		automaton.state->forEach(state | not stateDict->hasKey(state.name)) {
			var newState := object State {
				name := state.name;
			};
			stateDict->put(state.name, newState);
		}
	};
	
	return stateDict->values()->asSet();
}

*/

query createOutMessages(outMessage: Set(OutMessage)) : Set(OutMessage) {
	var resultMessages: Set(OutMessage);
	outMessage->forEach(message) {
		resultMessages += object OutMessage {
			operation := createOperation(message.operation.name);
			_object := createObject(message._object.name);
			_return := createReturn(message._return.value);
		}	
	};
	return resultMessages;
}

query createOperation(operationName: String): ioautomaton::Operation {
	return object ioautomaton::Operation {
		name := operationName
	}
}
query createReturn(returnValue: String): ioautomaton::Return {
	return object ioautomaton::Return {
		value := returnValue
	}
}
query createObject(objectName: String): ioautomaton::Object {
	return object ioautomaton::Object {
		name := objectName
	}
}




